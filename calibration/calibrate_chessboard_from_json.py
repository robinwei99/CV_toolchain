#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
calibrate_chessboard_from_json.py
Reads the JSON generated by gen_chessboard_letter_pdf.py, and performs
standard chessboard calibration using a set of jpg/png images from a folder.

Outputs calib.npz (cameraMatrix, distCoeffs, imageSize, rms, reproj_error)
optionally a calib.yml (OpenCV FileStorage format).

Example:
python calibrate_chessboard_from_json.py --cfg chessboard_9x6_25mm.json --folder ./captures \
  --save calib.npz --save-yaml calib.yml --use-sb

Notes
- The JSON must contain board_type == "chessboard" and fields: squares_x, squares_y
  (inner-corner counts), square_length_mm.
- Detection supports both findChessboardCornersSB (if available) and the classic
  findChessboardCorners; optional cornerSubPix refinement.
"""

import argparse
import json
from pathlib import Path
import sys
import glob

import numpy as np
import cv2

# ------------------------------ I/O -----------------------------------------

def load_config(json_path: str):
    with open(json_path, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    if cfg.get("board_type", "").lower() != "chessboard":
        raise ValueError("JSON is not chessboard type (board_type != 'chessboard').")
    req = ["squares_x", "squares_y", "square_length_mm"]
    for k in req:
        if k not in cfg:
            raise KeyError(f"JSON missing required field: {k}")
    return cfg


def collect_images(folder: str):
    exts = ("*.jpg","*.JPG","*.jpeg","*.png","*.bmp","*.tif","*.tiff")
    paths = []
    for e in exts:
        paths.extend(sorted(glob.glob(str(Path(folder) / e))))
    return paths

# --------------------------- Chessboard utils -------------------------------

def make_object_points(nx_inner: int, ny_inner: int, square_mm: float):
    """Return a (N,3) array of planar grid points in millimeters."""
    objp = np.zeros((ny_inner * nx_inner, 3), np.float32)
    # OpenCV's findChessboard corners are ordered row-major from top-left
    grid = np.mgrid[0:nx_inner, 0:ny_inner].T.reshape(-1, 2)
    objp[:, :2] = grid * float(square_mm)
    return objp


def detect_chessboard(gray, pattern_size, use_classic=False):
    """Detect inner corners. Returns (ok, corners) with corners shape (N,1,2)."""
    if not use_classic and hasattr(cv2, "findChessboardCornersSB"):
        try:
            ok, corners = cv2.findChessboardCornersSB(gray, pattern_size, flags=cv2.CALIB_CB_EXHAUSTIVE | cv2.CALIB_CB_ACCURACY)
            if ok:
                return True, corners
        except TypeError:
            # Some OpenCV builds require different signature; fall back below.
            pass
    # Classic detector
    flags = cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE
    ok, corners = cv2.findChessboardCorners(gray, pattern_size, flags)
    print("UseClassic")
    return ok, corners


def subpix_refine(gray, corners):
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 1e-4)
    win = (11, 11)
    zero_zone = (-1, -1)
    cv2.cornerSubPix(gray, corners, win, zero_zone, criteria)
    return corners

# --------------------------- Error metrics ----------------------------------

def mean_reproj_error(objpoints_list, imgpoints_list, rvecs, tvecs, K, D):
    tot_err2 = 0.0
    tot_pts = 0
    for objp, imgp, rvec, tvec in zip(objpoints_list, imgpoints_list, rvecs, tvecs):
        proj, _ = cv2.projectPoints(objp, rvec, tvec, K, D)
        err = cv2.norm(imgp, proj, cv2.NORM_L2)
        n = len(objp)
        tot_err2 += (err * err)
        tot_pts += n
    if tot_pts == 0:
        return float("nan")
    return float(np.sqrt(tot_err2 / tot_pts))

# ------------------------------- Main ---------------------------------------

def main():
    ap = argparse.ArgumentParser(description="Camera calibration with a standard chessboard (from JSON)")
    ap.add_argument("--cfg", required=True, help="JSON exported by gen_chessboard_letter_pdf.py")
    ap.add_argument("--folder", required=True, help="Folder containing jpg/png images")
    ap.add_argument("--use_classic", action="store_true", help="Prefer findChessboardCorners")
    ap.add_argument("--min-frames", type=int, default=8, help="Minimum accepted images for calibration")
    ap.add_argument("--save", default="calib.npz", help="Output npz (default: calib.npz)")
    args = ap.parse_args()

    cfg = load_config(args.cfg)
    nx, ny = int(cfg["squares_x"]), int(cfg["squares_y"])  # inner-corner counts
    square_mm = float(cfg["square_length_mm"])              # physical size of one square

    pattern_size = (nx, ny)
    objp = make_object_points(nx, ny, square_mm)

    # Gather images
    img_paths = collect_images(args.folder)
    if not img_paths:
        print(f"[ERR] No jpg/png images found in folder: {args.folder}")
        sys.exit(1)

    print(f"[INFO] Reading {len(img_paths)} images for chessboard calibration ({nx}x{ny} inner corners).")

    objpoints = []  # (N_i,3)
    imgpoints = []  # (N_i,1,2)
    imsize = None
    used = 0

    for p in img_paths:
        img = cv2.imread(p)
        if img is None:
            print(f"[WARN] Cannot read: {p}")
            continue
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (31,31), 0)
        if imsize is None:
            imsize = gray.shape[::-1]  # (w,h)

        ok, corners = detect_chessboard(gray, pattern_size, use_classic=args.use_classic)
        if not ok:
            print(f"[WARN] {Path(p).name}: chessboard NOT found")
            continue

        if args.use_classic or not hasattr(cv2, "findChessboardCornersSB"):
            corners = subpix_refine(gray, corners)

        if corners is None or len(corners) != nx * ny:
            print(f"[WARN] {Path(p).name}: invalid corner count ({0 if corners is None else len(corners)}), expected {nx*ny}")
            continue

        objpoints.append(objp.copy())
        imgpoints.append(corners)
        used += 1

    if used < max(args.min_frames, 3):
        print(f"[ERR] Only {used} valid detections, need at least {max(args.min_frames, 3)}")
        sys.exit(2)

    print(f"[INFO] Starting calibrateCamera with {used} valid images, image size {imsize}.")
    flags = 0
    # You could expose flags (e.g., FIX_K3) via CLI if desired.
    rms, K, D, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, imsize, None, None, flags=flags)

    mean_err = mean_reproj_error(objpoints, imgpoints, rvecs, tvecs, K, D)

    print(f"[RESULT] RMS = {rms:.6f}")
    print(f"[RESULT] Mean reprojection error (pixels) = {mean_err:.6f}")
    print(f"[RESULT] cameraMatrix =\n{K}")
    print(f"[RESULT] distCoeffs   = {D.ravel()}")

    # Save outputs
    out_npz = Path(args.save)
    out_npz.parent.mkdir(parents=True, exist_ok=True)
    np.savez(out_npz,
             cameraMatrix=K,
             distCoeffs=D,
             imageSize=np.array(imsize, dtype=np.int32),
             rms=float(rms),
             reproj_error=float(mean_err),
             method="Chessboard",
             config=Path(args.cfg).name)
    print(f"[OK] Saved parameters to {out_npz.resolve()}")
    print("TIP: Ensure you printed at 100% scale; move the board across depth/angles for diverse views.")


if __name__ == "__main__":
    main()
