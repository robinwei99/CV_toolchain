#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
calibrate_from_json.py
Reads the JSON generated by gen_charuco_letter_pdf.py, and performs ChArUco calibration
using a set of jpg/png images from a folder.
Outputs calib.npz (cameraMatrix, distCoeffs, imageSize, rms, reproj_error) and an optional calib.yml.

Example:
python calibrate_from_json.py --cfg charuco_5x7_30mm.json --folder ./captures \
  --save calib.npz --save-yaml calib.yml --refine
"""

import argparse
import json
from pathlib import Path
import sys
import glob

import cv2
import numpy as np

def load_config(json_path: str):
    with open(json_path, "r", encoding="utf-8") as f:
        cfg = json.load(f)
    # Basic validation
    if cfg.get("board_type", "").lower() != "charuco":
        raise ValueError("JSON is not ChArUco type (board_type != 'charuco').")
    req = ["squares_x", "squares_y", "square_length_mm", "marker_length_mm", "aruco_dict_id"]
    for k in req:
        if k not in cfg:
            raise KeyError(f"JSON missing required field: {k}")
    return cfg

def get_dictionary(dict_id: int):
    return cv2.aruco.getPredefinedDictionary(int(dict_id))

def create_charuco_board(nx, ny, square_len_mm, marker_len_mm, dictionary):
    # Note: Uses physical length (mm) for geometric computation
    try:
        board = cv2.aruco.CharucoBoard_create(nx, ny, float(square_len_mm), float(marker_len_mm), dictionary)
    except AttributeError:
        board = cv2.aruco.CharucoBoard((nx, ny), float(square_len_mm), float(marker_len_mm), dictionary)
    return board

def detect_markers(gray, dictionary):
    # Compatible with both old and new OpenCV ArUco APIs
    try:
        params = cv2.aruco.DetectorParameters()
        detector = cv2.aruco.ArucoDetector(dictionary, params)
        corners, ids, rejected = detector.detectMarkers(gray)
    except AttributeError:
        params = cv2.aruco.DetectorParameters_create()
        corners, ids, rejected = cv2.aruco.detectMarkers(gray, dictionary, parameters=params)
    return corners, ids, rejected

def refine_detect(gray, board, corners, ids, rejected, cameraMatrix=None, distCoeffs=None):
    # Optional refineDetectedMarkers (not available in some versions)
    if hasattr(cv2.aruco, "refineDetectedMarkers") and ids is not None:
        try:
            corners, ids, rejected, _ = cv2.aruco.refineDetectedMarkers(
                image=gray, board=board, detectedCorners=corners, detectedIds=ids,
                rejectedCorners=rejected, cameraMatrix=cameraMatrix, distCoeffs=distCoeffs)
        except TypeError:
            # Old function signature
            corners, ids, rejected, _ = cv2.aruco.refineDetectedMarkers(
                gray, board, corners, ids, rejected, cameraMatrix, distCoeffs)
    return corners, ids, rejected

def interpolate_charuco(gray, board, corners, ids):
    if ids is None or len(ids) == 0:
        return 0, None, None
    try:
        retval, ch_corners, ch_ids = cv2.aruco.interpolateCornersCharuco(
            markerCorners=corners, markerIds=ids, image=gray, board=board)
    except TypeError:
        retval, ch_corners, ch_ids = cv2.aruco.interpolateCornersCharuco(
            corners, ids, gray, board)
    return retval, ch_corners, ch_ids

def collect_images(folder: str):
    exts = ("*.jpg","*.JPG","*.jpeg","*.png","*.bmp","*.tif","*.tiff")
    paths = []
    for e in exts:
        paths.extend(sorted(glob.glob(str(Path(folder) / e))))
    return paths

def compute_mean_reproj_error_charuco(K, D, board, img_size, charuco_corners_list, charuco_ids_list):
    """
    For each image: use its ChArUco corners and corresponding 3D points to estimate extrinsics (solvePnP),
    then project them back into pixel space and compute the error.
    Returns the overall RMS pixel error.
    """
    tot_err2 = 0.0
    tot_pts = 0
    for ch_corners, ch_ids in zip(charuco_corners_list, charuco_ids_list):
        # Extract corresponding 3D points (unit: mm)
        obj = board.chessboardCorners[ch_ids.flatten(), :]  # (N,3)
        img = ch_corners  # (N,1,2)
        if len(obj) < 4:
            continue
        ok, rvec, tvec = cv2.solvePnP(obj, img, K, D, flags=cv2.SOLVEPNP_IPPE_SQUARE)
        if not ok:
            ok, rvec, tvec = cv2.solvePnP(obj, img, K, D)
            if not ok:
                continue
        proj, _ = cv2.projectPoints(obj, rvec, tvec, K, D)
        err = cv2.norm(img, proj, cv2.NORM_L2)
        n = len(obj)
        tot_err2 += (err*err)
        tot_pts += n
    if tot_pts == 0:
        return float("nan")
    return float(np.sqrt(tot_err2 / tot_pts))

def save_npz(path, K, D, imsize, rms, mean_err, method, cfg_basename):
    np.savez(path,
             cameraMatrix=K,
             distCoeffs=D,
             imageSize=np.array(imsize, dtype=np.int32),
             rms=float(rms),
             reproj_error=float(mean_err),
             method=str(method),
             config=str(cfg_basename))
    print(f"[OK] Saved parameters to {Path(path).resolve()}")

def save_yaml(path, K, D):
    fs = cv2.FileStorage(path, cv2.FILE_STORAGE_WRITE)
    fs.write("cameraMatrix", K)
    fs.write("distCoeffs", D)
    fs.release()
    print(f"[OK] Saved YAML to {Path(path).resolve()}")

def main():
    ap = argparse.ArgumentParser(description="Perform camera calibration using ChArUco JSON + folder images")
    ap.add_argument("--cfg", required=True, help="JSON exported by gen_charuco_letter_pdf.py")
    ap.add_argument("--folder", required=True, help="Folder containing jpg/png images")
    ap.add_argument("--min-charuco", type=int, default=10, help="Minimum number of detected ChArUco corners to use an image (default: 4)")
    ap.add_argument("--save", default="calib.npz", help="Output npz (default: calib.npz)")
    ap.add_argument("--save-yaml", default=None, help="Optional: also save YAML")
    ap.add_argument("--refine", action="store_true", help="Enable refineDetectedMarkers() optimization")
    args = ap.parse_args()

    cfg = load_config(args.cfg)
    nx, ny = int(cfg["squares_x"]), int(cfg["squares_y"])
    square_mm = float(cfg["square_length_mm"])
    marker_mm = float(cfg["marker_length_mm"])
    dict_id = int(cfg["aruco_dict_id"])

    dictionary = get_dictionary(dict_id)
    board = create_charuco_board(nx, ny, square_mm, marker_mm, dictionary)

    # Collect images
    img_paths = collect_images(args.folder)
    if not img_paths:
        print(f"[ERR] No jpg/png images found in folder: {args.folder}")
        sys.exit(1)

    print(f"[INFO] Reading {len(img_paths)} images for ChArUco calibration.")
    charuco_corners_all = []
    charuco_ids_all = []
    imsize = None
    used = 0

    for p in img_paths:
        img = cv2.imread(p)
        if img is None:
            print(f"[WARN] Cannot read: {p}")
            continue
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        if imsize is None:
            imsize = gray.shape[::-1]  # (w,h)

        corners, ids, rejected = detect_markers(gray, dictionary)
        if args.refine:
            corners, ids, rejected = refine_detect(gray, board, corners, ids, rejected)

        retval, ch_corners, ch_ids = interpolate_charuco(gray, board, corners, ids)
        if retval and ch_corners is not None and ch_ids is not None and len(ch_corners) >= args.min_charuco:
            charuco_corners_all.append(ch_corners)
            charuco_ids_all.append(ch_ids)
            used += 1
        else:
            print(f"[WARN] {Path(p).name}: Not enough ChArUco corners ({0 if ch_corners is None else len(ch_corners)})")

    # Calibration
    print(f"[INFO] Starting calibrateCameraCharuco with {used} valid images, image size {imsize}.")
    try:
        rms, K, D, rvecs, tvecs = cv2.aruco.calibrateCameraCharuco(
            charucoCorners=charuco_corners_all,
            charucoIds=charuco_ids_all,
            board=board,
            imageSize=imsize,
            cameraMatrix=None,
            distCoeffs=None
        )
    except TypeError:
        rms, K, D, rvecs, tvecs = cv2.aruco.calibrateCameraCharuco(
            charuco_corners_all, charuco_ids_all, board, imsize, None, None
        )

    # Compute mean reprojection error (pixels)
    mean_err = compute_mean_reproj_error_charuco(K, D, board, imsize,
                                                 charuco_corners_all, charuco_ids_all)

    print(f"[RESULT] RMS = {rms:.6f}")
    print(f"[RESULT] Mean reprojection error (pixels) = {mean_err:.6f}")
    print(f"[RESULT] cameraMatrix =\n{K}")
    print(f"[RESULT] distCoeffs   = {D.ravel()}")

    # Save
    out_npz = Path(args.save)
    out_npz.parent.mkdir(parents=True, exist_ok=True)
    save_npz(out_npz, K, D, imsize, rms, mean_err, method="Charuco", cfg_basename=Path(args.cfg).name)
    if args.save_yaml:
        save_yaml(args.save_yaml, K, D)

if __name__ == "__main__":
    main()
